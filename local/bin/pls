#!/usr/bin/env bash
set -e

VERSION="1.6.0"

PLS_DIR="${PLS_DIR:-$HOME/.local/share/pls}"
PLS_CONFIG_DIR="${PLS_CONFIG_DIR:-$HOME/.config/pls}"
PLS_SITES_DIR="$PLS_CONFIG_DIR/sites"
PLS_CERTS_DIR="$PLS_CONFIG_DIR/certs"
PLS_LOG_DIR="$PLS_DIR/logs"
CADDYFILE="$PLS_CONFIG_DIR/Caddyfile"

PHP_DIR="${PHP_DIR:-$HOME/.local/php}"
PHP_VERSIONS_DIR="$PHP_DIR/versions"
PHP_RUN_DIR="$PHP_DIR/run"

MYSQL_DIR="${MYSQL_DIR:-$HOME/.local/mysql}"
MYSQL_DATA_DIR="$MYSQL_DIR/data"
MYSQL_CONTAINER_NAME="pls-mysql"
MYSQL_IMAGE="${MYSQL_IMAGE:-mysql:8.0}"
MYSQL_PORT="${MYSQL_PORT:-3306}"

MAIL_CONTAINER_NAME="pls-mailpit"
MAIL_IMAGE="${MAIL_IMAGE:-axllent/mailpit:latest}"
MAIL_SMTP_PORT="${MAIL_SMTP_PORT:-1025}"
MAIL_UI_PORT="${MAIL_UI_PORT:-8025}"

PROJECTS_DIR="${PROJECTS_DIR:-$HOME/Codes}"

php_get_versions() {
    find "$PHP_VERSIONS_DIR" -maxdepth 1 -type d -name "php-*" 2>/dev/null | \
        sed 's|.*/php-||' | sort -V
}

detect_default_php_version() {
    local latest
    latest=$(php_get_versions | tail -1)
    if [ -n "$latest" ]; then
        echo "$latest"
    else
        echo "8.5"
    fi
}
DEFAULT_PHP_VERSION="${DEFAULT_PHP_VERSION:-$(detect_default_php_version)}"

detect_distro() {
    DISTRO_FAMILY="unknown"
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        case "$ID" in
            arch|endeavouros|manjaro|garuda)
                DISTRO_FAMILY="arch" ;;
            debian|ubuntu|linuxmint|pop|elementary|zorin|kali)
                DISTRO_FAMILY="debian" ;;
            *)
                case "${ID_LIKE:-}" in
                    *arch*)            DISTRO_FAMILY="arch" ;;
                    *debian*|*ubuntu*) DISTRO_FAMILY="debian" ;;
                esac ;;
        esac
    fi
}
detect_distro

CADDY_BIN="${CADDY_BIN:-$(command -v caddy 2>/dev/null || echo /usr/sbin/caddy)}"
SPC_DOCKER_IMAGE="pls-spc"
SPC_CACHE_DIR="$PLS_DIR/spc-downloads"
SPC_EXTENSIONS="${SPC_EXTENSIONS:-bcmath,calendar,ctype,curl,dom,exif,fileinfo,filter,gd,iconv,intl,mbstring,mysqli,mysqlnd,opcache,openssl,pcntl,pdo,pdo_mysql,pdo_sqlite,phar,posix,readline,session,simplexml,sockets,sodium,sqlite3,tokenizer,xml,xmlreader,xmlwriter,zip,zlib}"

RED=$'\033[0;31m'
GREEN=$'\033[0;32m'
YELLOW=$'\033[1;33m'
BLUE=$'\033[0;34m'
CYAN=$'\033[0;36m'
BOLD=$'\033[1m'
NC=$'\033[0m'

pkg_install() {
    case "$DISTRO_FAMILY" in
        arch)   sudo pacman -S --needed --noconfirm "$@" ;;
        debian) sudo apt-get install -y "$@" ;;
        *)      echo "Unsupported distro. Install manually: $*"; return 1 ;;
    esac
}

pkg_hint() {
    case "$DISTRO_FAMILY" in
        arch)   echo "sudo pacman -S $*" ;;
        debian) echo "sudo apt install $*" ;;
        *)      echo "(install: $*)" ;;
    esac
}

mkdir -p "$PLS_CONFIG_DIR" "$PLS_SITES_DIR" "$PLS_CERTS_DIR" "$PLS_LOG_DIR" "$PHP_RUN_DIR"

print_header() {
    echo -e "${BOLD}${CYAN}$1${NC}"
}

print_success() {
    echo -e "${GREEN}âœ“${NC} $1"
}

print_error() {
    echo -e "${RED}âœ—${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}âš ${NC} $1"
}

print_info() {
    echo -e "${BLUE}â†’${NC} $1"
}

resolve_site() {
    local usage="$1" name="$2"
    if [ -z "$name" ]; then
        print_error "Usage: pls $usage <hostname>"
        return 1
    fi
    local hostname
    hostname=$(ensure_test_suffix "$name")
    local site_file="$PLS_SITES_DIR/${hostname}.conf"
    if [ ! -f "$site_file" ]; then
        print_error "Site not found: $hostname"
        return 1
    fi
    echo "$hostname"
}

open_url() {
    local url="$1"
    if command -v xdg-open &>/dev/null; then
        xdg-open "$url" 2>/dev/null &
    elif command -v open &>/dev/null; then
        open "$url"
    elif command -v wslview &>/dev/null; then
        wslview "$url"
    else
        print_error "No browser opener found"
        echo "  URL: $url"
        return 1
    fi
}

require_docker() {
    if ! command -v docker &> /dev/null; then
        print_error "Docker is not installed"
        local _docker_pkg="docker"
        [ "$DISTRO_FAMILY" = "debian" ] && _docker_pkg="docker.io"
        echo "  Install: $(pkg_hint "$_docker_pkg")"
        echo "           sudo systemctl enable --now docker"
        echo "           sudo usermod -aG docker \$USER"
        return 1
    fi
    if ! docker info &> /dev/null; then
        print_error "Docker is not running or user lacks permissions"
        echo "  Start:  sudo systemctl start docker"
        echo "  Access: sudo usermod -aG docker \$USER && newgrp docker"
        return 1
    fi
}

init_caddyfile() {
    if [ ! -f "$CADDYFILE" ]; then
        cat > "$CADDYFILE" << EOF
{
    admin localhost:2019
    auto_https off
}

import $PLS_SITES_DIR/*.conf
EOF
        print_success "Caddyfile created"
    fi
}

caddy_is_running() {
    systemctl --user is-active --quiet pls-caddy.service 2>/dev/null
}

caddy_start() {
    if caddy_is_running; then
        print_warning "Caddy is already running"
        return 0
    fi

    init_caddyfile
    print_info "Starting Caddy..."
    systemctl --user start pls-caddy.service
    sleep 1

    if caddy_is_running; then
        print_success "Caddy started"
    else
        print_error "Failed to start Caddy"
        return 1
    fi
}

caddy_stop() {
    if ! caddy_is_running; then
        print_warning "Caddy is not running"
        return 0
    fi

    print_info "Stopping Caddy..."
    systemctl --user stop pls-caddy.service
    print_success "Caddy stopped"
}

caddy_reload() {
    if ! caddy_is_running; then
        print_error "Caddy is not running"
        return 1
    fi

    print_info "Reloading Caddy configuration..."
    systemctl --user reload pls-caddy.service
    print_success "Configuration reloaded"
}

php_is_running() {
    local version="$1"
    local pid_file="$PHP_RUN_DIR/php${version}-fpm.pid"

    if [ -f "$pid_file" ] && ps -p "$(cat "$pid_file")" > /dev/null 2>&1; then
        return 0
    fi
    return 1
}

php_start() {
    local version="$1"
    local version_dir="$PHP_VERSIONS_DIR/php-${version}"
    local fpm_bin="$version_dir/php-fpm"
    local fpm_conf="$version_dir/php-fpm.conf"

    if [ ! -x "$fpm_bin" ]; then
        print_error "PHP $version not found"
        return 1
    fi

    if php_is_running "$version"; then
        print_warning "PHP $version is already running"
        return 0
    fi

    print_info "Starting PHP $version FPM..."
    "$fpm_bin" --fpm-config "$fpm_conf" --daemonize
    print_success "PHP $version FPM started"
}

php_stop() {
    local version="$1"
    local pid_file="$PHP_RUN_DIR/php${version}-fpm.pid"

    if [ ! -f "$pid_file" ]; then
        print_warning "PHP $version is not running"
        return 0
    fi

    local pid=$(cat "$pid_file")
    print_info "Stopping PHP $version FPM..."
    kill "$pid" 2>/dev/null || true
    rm -f "$pid_file"
    print_success "PHP $version FPM stopped"
}

php_start_all() {
    for version in $(php_get_versions); do
        php_start "$version" 2>/dev/null || true
    done
}

php_stop_all() {
    for version in $(php_get_versions); do
        php_stop "$version" 2>/dev/null || true
    done
}

mysql_is_running() {
    docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^${MYSQL_CONTAINER_NAME}$"
}

mysql_start() {
    require_docker || return 1

    if mysql_is_running; then
        print_warning "MySQL is already running"
        return 0
    fi

    # Check if container exists but stopped
    if docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^${MYSQL_CONTAINER_NAME}$"; then
        print_info "Starting existing MySQL container..."
        docker start "$MYSQL_CONTAINER_NAME" > /dev/null
    else
        print_info "Creating MySQL container..."
        docker run -d \
            --name "$MYSQL_CONTAINER_NAME" \
            -e MYSQL_ALLOW_EMPTY_PASSWORD=yes \
            -p "127.0.0.1:${MYSQL_PORT}:3306" \
            -v "$MYSQL_DATA_DIR:/var/lib/mysql" \
            "$MYSQL_IMAGE" > /dev/null || {
            print_error "Failed to create MySQL container"
            return 1
        }
    fi

    print_info "Waiting for MySQL to be ready..."
    local retries=30
    while [ $retries -gt 0 ]; do
        if docker exec "$MYSQL_CONTAINER_NAME" mysqladmin ping -h localhost --silent 2>/dev/null; then
            print_success "MySQL started (port $MYSQL_PORT)"
            return 0
        fi
        sleep 1
        ((retries--))
    done

    print_error "MySQL failed to become ready"
    return 1
}

mysql_stop() {
    if ! mysql_is_running; then
        print_warning "MySQL is not running"
        return 0
    fi

    print_info "Stopping MySQL..."
    docker stop "$MYSQL_CONTAINER_NAME" > /dev/null 2>&1
    print_success "MySQL stopped"
}

mail_is_running() {
    docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^${MAIL_CONTAINER_NAME}$"
}

mail_start() {
    require_docker || return 1

    if mail_is_running; then
        print_warning "Mailpit is already running"
        return 0
    fi

    if docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^${MAIL_CONTAINER_NAME}$"; then
        print_info "Starting existing Mailpit container..."
        docker start "$MAIL_CONTAINER_NAME" > /dev/null
    else
        print_info "Creating Mailpit container..."
        docker run -d \
            --name "$MAIL_CONTAINER_NAME" \
            -p "127.0.0.1:${MAIL_SMTP_PORT}:1025" \
            -p "127.0.0.1:${MAIL_UI_PORT}:8025" \
            "$MAIL_IMAGE" > /dev/null || {
            print_error "Failed to create Mailpit container"
            return 1
        }
    fi

    sleep 1
    if mail_is_running; then
        print_success "Mailpit started (SMTP: $MAIL_SMTP_PORT, UI: $MAIL_UI_PORT)"
        return 0
    fi

    print_error "Mailpit failed to start"
    return 1
}

mail_stop() {
    if ! mail_is_running; then
        print_warning "Mailpit is not running"
        return 0
    fi

    print_info "Stopping Mailpit..."
    docker stop "$MAIL_CONTAINER_NAME" > /dev/null 2>&1
    print_success "Mailpit stopped"
}

php_list() {
    echo ""
    print_header "PHP versions"
    echo ""

    local versions=$(php_get_versions)

    if [ -z "$versions" ]; then
        print_warning "No PHP version installed"
        echo "  Install: pls install php"
        return 0
    fi

    for version in $versions; do
        local version_dir="$PHP_VERSIONS_DIR/php-${version}"
        local php_full=$("$version_dir/php" -v 2>/dev/null | head -1 | cut -d' ' -f1-2 || echo "PHP $version")

        if php_is_running "$version"; then
            echo -e "  ${GREEN}â—${NC} ${BOLD}$php_full${NC} ${GREEN}[running]${NC}"
        else
            echo -e "  ${RED}â—${NC} $php_full ${YELLOW}[stopped]${NC}"
        fi
    done
    echo ""
}

generate_cert() {
    local hostname="$1"
    local cert_file="$PLS_CERTS_DIR/${hostname}.pem"
    local key_file="$PLS_CERTS_DIR/${hostname}-key.pem"

    if [ -f "$cert_file" ] && [ -f "$key_file" ]; then
        return 0
    fi

    if ! command -v mkcert &> /dev/null; then
        print_error "mkcert is not installed"
        local _nss_pkg="nss"
        [ "$DISTRO_FAMILY" = "debian" ] && _nss_pkg="libnss3-tools"
        echo "  Install: $(pkg_hint mkcert "$_nss_pkg") && mkcert -install"
        return 1
    fi

    print_info "Generating certificate: $hostname"
    mkcert -cert-file "$cert_file" -key-file "$key_file" \
        "$hostname" "*.${hostname}" localhost 127.0.0.1 ::1 > /dev/null 2>&1

    if [ -f "$cert_file" ]; then
        print_success "Certificate created"
    else
        print_error "Certificate generation failed"
        return 1
    fi
}

detect_php_version() {
    local project_path="${1:-.}"
    local detected="" source=""

    if [ -f "$project_path/composer.json" ]; then
        detected=$(grep -oP '"php"\s*:\s*"[^"]*(\d+\.\d+)' "$project_path/composer.json" 2>/dev/null | grep -oP '\d+\.\d+' | head -1)
        [ -n "$detected" ] && source="composer.json"
    fi

    for file in .php-version .phpversion; do
        if [ -z "$detected" ] && [ -f "$project_path/$file" ]; then
            detected=$(grep -oP '^\d+\.\d+' "$project_path/$file" 2>/dev/null | head -1)
            [ -n "$detected" ] && source="$file"
        fi
    done

    echo "${detected:-$DEFAULT_PHP_VERSION}|${source:-default}"
}

ensure_test_suffix() {
    local name="$1"
    [[ "$name" == *.test ]] && echo "$name" || echo "${name}.test"
}

generate_site_config() {
    local hostname="$1"
    local doc_root="$2"
    local php_socket="$3"
    local comment="${4:-}"

    cat << EOF
${comment:+# $comment
}http://${hostname} {
    redir https://{host}{uri} permanent
}

https://${hostname} {
    tls $PLS_CERTS_DIR/${hostname}.pem $PLS_CERTS_DIR/${hostname}-key.pem
    root * ${doc_root}
    php_fastcgi ${php_socket}
    file_server
    log {
        output file $PLS_LOG_DIR/${hostname}.log
    }
}
EOF
}

serve_project() {
    local input="$1"
    local project_path="" project_name="" hostname=""

    if [ -z "$input" ]; then
        local current_dir=$(pwd)
        if [[ "$current_dir" != "$PROJECTS_DIR"/* ]]; then
            print_error "Not in ~/Codes project folder"
            echo ""
            echo "  Usage:"
            echo "    cd ~/Codes/myproject && pls serve"
            echo "    pls serve myproject"
            return 1
        fi
        project_name=$(echo "$current_dir" | sed "s|$PROJECTS_DIR/||" | cut -d'/' -f1)
    else
        project_name="${input%.test}"
    fi

    hostname=$(ensure_test_suffix "$project_name")
    project_path="$PROJECTS_DIR/$project_name"

    if [ ! -d "$project_path" ]; then
        print_error "Project not found: $project_path"
        echo ""
        cmd_projects
        return 1
    fi

    local site_file="$PLS_SITES_DIR/${hostname}.conf"
    if [ -f "$site_file" ]; then
        print_warning "Site already exists: $hostname"
        return 1
    fi

    local php_info=$(detect_php_version "$project_path")
    local php_version=${php_info%|*}
    local php_source=${php_info#*|}

    local doc_root="$project_path"
    for dir in public web; do
        [ -d "$project_path/$dir" ] && doc_root="$project_path/$dir" && break
    done

    if [ ! -S "$PHP_RUN_DIR/php${php_version}-fpm.sock" ]; then
        print_error "PHP $php_version FPM is not running"
        echo "  Start it: pls start"
        return 1
    fi
    local php_socket="unix/$PHP_RUN_DIR/php${php_version}-fpm.sock"

    generate_cert "$hostname" || return 1
    generate_site_config "$hostname" "$doc_root" "$php_socket" > "$site_file"

    echo ""
    print_success "Site created: $project_name"
    echo -e "  ${BLUE}URL:${NC}  https://${hostname}"
    echo -e "  ${BLUE}PHP:${NC}  $php_version ($php_source)"
    echo -e "  ${BLUE}Root:${NC} $doc_root"

    caddy_is_running && caddy_reload || print_warning "Caddy is not running. Start it: pls start"
}

alias_site() {
    local existing="$1" alias_name="$2"

    if [ -z "$existing" ] || [ -z "$alias_name" ]; then
        print_error "Usage: pls alias <existing-site> <new-alias>"
        echo "  Example: pls alias myproject api.myproject"
        return 1
    fi

    existing=$(ensure_test_suffix "$existing")
    alias_name=$(ensure_test_suffix "$alias_name")

    local existing_file="$PLS_SITES_DIR/${existing}.conf"
    if [ ! -f "$existing_file" ]; then
        print_error "Site not found: $existing"
        echo ""
        list_sites
        return 1
    fi

    local alias_file="$PLS_SITES_DIR/${alias_name}.conf"
    if [ -f "$alias_file" ]; then
        print_warning "Site already exists: $alias_name"
        return 1
    fi

    local doc_root=$(grep -oP 'root \* \K[^\s]+' "$existing_file" | head -1)
    local php_socket=$(grep -oP 'php_fastcgi \K[^\s]+' "$existing_file" | head -1)

    if [ -z "$doc_root" ] || [ -z "$php_socket" ]; then
        print_error "Could not parse existing site config"
        return 1
    fi

    generate_cert "$alias_name" || return 1
    generate_site_config "$alias_name" "$doc_root" "$php_socket" "Alias for: ${existing}" > "$alias_file"

    echo ""
    print_success "Alias created: $alias_name -> $existing"
    echo -e "  ${BLUE}URL:${NC}  https://${alias_name}"
    echo -e "  ${BLUE}Root:${NC} $doc_root"

    caddy_is_running && caddy_reload || print_warning "Caddy is not running. Start it: pls start"
}

remove_site() {
    if [ -z "$1" ]; then
        print_error "Usage: pls remove <hostname>"
        return 1
    fi

    local hostname=$(ensure_test_suffix "$1")
    local site_file="$PLS_SITES_DIR/${hostname}.conf"

    if [ ! -f "$site_file" ]; then
        print_error "Site not found: $hostname"
        return 1
    fi

    rm -f "$site_file"
    rm -f "$PLS_CERTS_DIR/${hostname}.pem" "$PLS_CERTS_DIR/${hostname}-key.pem"

    print_success "Site removed: $hostname"

    caddy_is_running && caddy_reload
}

list_sites() {
    echo ""
    print_header "Active sites"
    echo ""

    local sites=("$PLS_SITES_DIR"/*.conf)
    if [ ! -f "${sites[0]}" ]; then
        print_warning "No sites configured"
        echo "  Create one: cd ~/Codes/myproject && pls serve"
        echo ""
        return 0
    fi

    for site_file in "${sites[@]}"; do
        local hostname=$(basename "$site_file" .conf)
        local alias_for=$(grep -oP '^# Alias for: \K.+' "$site_file" 2>/dev/null)
        local php_ver=$(grep -oP 'php\K[0-9.]+' "$site_file" | head -1)

        if [ -n "$alias_for" ]; then
            echo -e "  ${CYAN}â†ª${NC}  https://${hostname} ${YELLOW}[alias â†’ ${alias_for}]${NC}"
        else
            echo -e "  ${GREEN}ðŸ”’${NC} ${BOLD}https://${hostname}${NC} â†’ PHP $php_ver"
        fi
    done
    echo ""
}

open_site() {
    local hostname
    hostname=$(resolve_site "open" "$1") || return 1

    local url="https://${hostname}"
    print_info "Opening $url"
    open_url "$url"
}

edit_site() {
    local hostname
    hostname=$(resolve_site "edit" "$1") || return 1
    local site_file="$PLS_SITES_DIR/${hostname}.conf"

    local editor="${EDITOR:-${VISUAL:-nano}}"
    "$editor" "$site_file"

    if caddy_is_running; then
        read -rp "Reload Caddy config? [Y/n] " answer
        [[ "${answer:-y}" =~ ^[Yy]?$ ]] && caddy_reload
    fi
}

info_site() {
    local hostname
    hostname=$(resolve_site "info" "$1") || return 1
    local site_file="$PLS_SITES_DIR/${hostname}.conf"

    local alias_for=$(grep -oP '^# Alias for: \K.+' "$site_file" 2>/dev/null)
    local doc_root=$(grep -oP 'root \* \K[^\s]+' "$site_file" | head -1)
    local php_socket=$(grep -oP 'php_fastcgi \K[^\s]+' "$site_file" | head -1)
    local php_ver=$(echo "$php_socket" | grep -oP 'php\K[0-9.]+')
    local cert_file="$PLS_CERTS_DIR/${hostname}.pem"
    local log_file="$PLS_LOG_DIR/${hostname}.log"

    echo ""
    print_header "Site: $hostname"
    echo ""
    echo -e "  ${BLUE}URL:${NC}      https://${hostname}"
    [ -n "$alias_for" ] && echo -e "  ${BLUE}Alias of:${NC} $alias_for"
    echo -e "  ${BLUE}Root:${NC}     $doc_root"
    echo -e "  ${BLUE}PHP:${NC}      $php_ver"
    echo -e "  ${BLUE}Socket:${NC}   $php_socket"
    echo -e "  ${BLUE}Config:${NC}   $site_file"
    echo -e "  ${BLUE}Cert:${NC}     $cert_file"
    echo -e "  ${BLUE}Log:${NC}      $log_file"

    if [ -f "$cert_file" ]; then
        local expiry=$(openssl x509 -enddate -noout -in "$cert_file" 2>/dev/null | cut -d= -f2)
        [ -n "$expiry" ] && echo -e "  ${BLUE}Expires:${NC}  $expiry"
    fi

    if [ -f "$log_file" ]; then
        local log_size=$(du -h "$log_file" 2>/dev/null | cut -f1)
        echo -e "  ${BLUE}Log size:${NC} $log_size"
    fi
    echo ""
}

cmd_trust() {
    echo ""
    print_header "Certificate Trust Status"
    echo ""

    if ! command -v mkcert &>/dev/null; then
        print_error "mkcert is not installed"
        local _nss_pkg="nss"
        [ "$DISTRO_FAMILY" = "debian" ] && _nss_pkg="libnss3-tools"
        echo "  Install: $(pkg_hint mkcert "$_nss_pkg")"
        return 1
    fi

    local ca_root=$(mkcert -CAROOT 2>/dev/null)
    local ca_cert="$ca_root/rootCA.pem"

    if [ ! -f "$ca_cert" ]; then
        print_warning "Local CA not created yet"
        echo ""
        read -rp "Create and install local CA? [Y/n] " answer
        if [[ "${answer:-y}" =~ ^[Yy]?$ ]]; then
            mkcert -install
            print_success "Local CA installed"
        fi
        return
    fi

    print_success "CA Root: $ca_root"

    local ca_expiry=$(openssl x509 -enddate -noout -in "$ca_cert" 2>/dev/null | cut -d= -f2)
    local ca_subject=$(openssl x509 -subject -noout -in "$ca_cert" 2>/dev/null | sed 's/subject=//')
    echo -e "  ${BLUE}Subject:${NC} $ca_subject"
    echo -e "  ${BLUE}Expires:${NC} $ca_expiry"

    echo ""
    local _ca_trusted=false
    if command -v trust &>/dev/null && trust list 2>/dev/null | grep -qi "mkcert"; then
        _ca_trusted=true
    elif find /usr/local/share/ca-certificates -name '*mkcert*' -print -quit 2>/dev/null | grep -q .; then
        _ca_trusted=true
    fi
    if $_ca_trusted; then
        print_success "CA is trusted by the system"
    else
        print_warning "CA may not be in system trust store"
        echo ""
        read -rp "Reinstall CA to trust store? [Y/n] " answer
        if [[ "${answer:-y}" =~ ^[Yy]?$ ]]; then
            mkcert -install
            print_success "CA reinstalled"
        fi
    fi

    if [ -d "$HOME/.mozilla/firefox" ]; then
        echo ""
        if certutil -L -d "$HOME/.mozilla/firefox/"*.default* 2>/dev/null | grep -q "mkcert"; then
            print_success "CA is trusted by Firefox"
        else
            print_warning "CA may not be trusted by Firefox"
            echo "  Run: mkcert -install"
        fi
    fi

    echo ""
}

cmd_start() {
    echo ""
    print_header "Starting PHP Local Server"
    echo ""
    mysql_start 2>/dev/null || true
    mail_start 2>/dev/null || true
    php_start_all
    caddy_start

    echo ""
    print_success "Environment started"
    echo ""
}

cmd_stop() {
    echo ""
    print_header "Stopping PHP Local Server"
    echo ""

    caddy_stop
    php_stop_all
    mysql_stop 2>/dev/null || true
    mail_stop 2>/dev/null || true

    echo ""
    print_success "Environment stopped"
    echo ""
}

cmd_restart() {
    cmd_stop
    sleep 1
    cmd_start
}

cmd_status() {
    echo ""
    print_header "PHP Local Server"
    echo ""

    echo -n "  Caddy:   "
    caddy_is_running && echo -e "${GREEN}â—${NC} running" || echo -e "${RED}â—${NC} stopped"

    local php_running=0 php_total=0
    for version in $(php_get_versions); do
        ((php_total++))
        php_is_running "$version" && ((php_running++))
    done

    echo -n "  PHP-FPM: "
    if [ "$php_total" -eq 0 ]; then
        echo -e "${RED}â—${NC} not installed"
    elif [ "$php_running" -eq "$php_total" ]; then
        echo -e "${GREEN}â—${NC} $php_running/$php_total running"
    elif [ "$php_running" -gt 0 ]; then
        echo -e "${YELLOW}â—${NC} $php_running/$php_total running"
    else
        echo -e "${RED}â—${NC} stopped"
    fi

    echo -n "  MySQL:   "
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}â—${NC} docker not installed"
    elif mysql_is_running; then
        echo -e "${GREEN}â—${NC} running (docker)"
    elif docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^${MYSQL_CONTAINER_NAME}$"; then
        echo -e "${RED}â—${NC} stopped"
    else
        echo -e "${YELLOW}â—${NC} not created"
    fi

    echo -n "  Mailpit: "
    if ! command -v docker &> /dev/null; then
        echo -e "${RED}â—${NC} docker not installed"
    elif mail_is_running; then
        echo -e "${GREEN}â—${NC} running (SMTP: $MAIL_SMTP_PORT, UI: https://mail.test)"
    elif docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^${MAIL_CONTAINER_NAME}$"; then
        echo -e "${RED}â—${NC} stopped"
    else
        echo -e "${YELLOW}â—${NC} not created"
    fi

    local sites=("$PLS_SITES_DIR"/*.conf)
    local site_count=0
    [ -f "${sites[0]}" ] && site_count=${#sites[@]}
    echo -e "  Sites:   $site_count active"

    list_sites
}

cmd_projects() {
    echo ""
    print_header "Projects ($PROJECTS_DIR)"
    echo ""

    if [ ! -d "$PROJECTS_DIR" ]; then
        print_error "Project folder does not exist: $PROJECTS_DIR"
        return 1
    fi

    local projects=$(find "$PROJECTS_DIR" -maxdepth 1 -type d -not -path "$PROJECTS_DIR" -printf "%f\n" 2>/dev/null | sort)

    if [ -z "$projects" ]; then
        print_warning "No projects found"
        return 0
    fi

    for project in $projects; do
        local served=""
        [ -f "$PLS_SITES_DIR/${project}.test.conf" ] && served=" ${GREEN}[active]${NC}"
        echo -e "  ${BLUE}â€¢${NC} $project$served"
    done
    echo ""
}

php_get_bin() {
    local version="$1"
    local php_bin="$PHP_VERSIONS_DIR/php-${version}/php"

    [ -x "$php_bin" ] && echo "$php_bin"
}

php_run() {
    local php_info=$(detect_php_version)
    local php_version=${php_info%|*}
    local php_source=${php_info#*|}
    local php_bin=$(php_get_bin "$php_version")

    [ -z "$php_bin" ] && { print_error "PHP $php_version not found"; return 1; }

    if [ $# -eq 0 ]; then
        echo -e "${BLUE}PHP $php_version${NC} ($php_source)"
        "$php_bin" -v
        return 0
    fi

    exec "$php_bin" "$@"
}

cmd_php() {
    local subcmd="${1:-}"

    case "$subcmd" in
        list|ls)
            php_list ;;
        fpm)
            shift; cmd_php "${@:-list}" ;;
        start|stop)
            shift
            [ -z "$1" ] && php_${subcmd}_all || php_${subcmd} "$1" ;;
        restart)
            shift
            if [ -z "$1" ]; then
                php_stop_all; sleep 1; php_start_all
            else
                php_stop "$1"; sleep 1; php_start "$1"
            fi ;;
        *)
            php_run "$@" ;;
    esac
}

find_composer() {
    local pls_composer="$PLS_DIR/composer"
    [ -f "$pls_composer" ] && { echo "$pls_composer"; return; }

    for path in \
        "./composer.phar" \
        "$HOME/.local/bin/composer" \
        "$HOME/.composer/composer.phar"
    do
        [ -n "$path" ] && [ -f "$path" ] && echo "$path" && return
    done
    return 1
}

cmd_composer() {
    local php_info=$(detect_php_version)
    local php_version=${php_info%|*}
    local php_source=${php_info#*|}
    local php_bin=$(php_get_bin "$php_version")

    [ -z "$php_bin" ] && { print_error "PHP $php_version not found"; return 1; }

    local composer_bin=$(find_composer)
    [ -z "$composer_bin" ] && { print_error "Composer not found"; echo "  Install: https://getcomposer.org/download/"; return 1; }

    if [ $# -eq 0 ]; then
        echo -e "${BLUE}Composer${NC} + PHP $php_version ($php_source)"
        exec "$php_bin" "$composer_bin" --version
    fi

    exec "$php_bin" "$composer_bin" "$@"
}

cmd_mysql() {
    local subcmd="${1:-}"

    case "$subcmd" in
        start)
            mysql_start ;;
        stop)
            mysql_stop ;;
        restart)
            mysql_stop; sleep 1; mysql_start ;;
        status)
            if mysql_is_running; then
                print_success "MySQL is running"
                echo "  Container: $MYSQL_CONTAINER_NAME"
                echo "  Port:      127.0.0.1:$MYSQL_PORT"
                echo "  Image:     $(docker inspect --format '{{.Config.Image}}' "$MYSQL_CONTAINER_NAME" 2>/dev/null)"
            else
                print_warning "MySQL is not running"
            fi
            ;;
        export)
            shift
            local db="$1" file="$2"
            if [ -z "$db" ] || [ -z "$file" ]; then
                print_error "Usage: pls mysql export <database> <file>"
                return 1
            fi
            if ! mysql_is_running; then
                print_error "MySQL is not running"
                return 1
            fi
            print_info "Exporting $db to $file..."
            docker exec "$MYSQL_CONTAINER_NAME" mysqldump -u root "$db" > "$file" || {
                print_error "Export failed"
                return 1
            }
            print_success "Exported $db to $file"
            ;;
        import)
            shift
            local db="$1" file="$2"
            if [ -z "$db" ] || [ -z "$file" ]; then
                print_error "Usage: pls mysql import <database> <file>"
                return 1
            fi
            if [ ! -f "$file" ]; then
                print_error "File not found: $file"
                return 1
            fi
            if ! mysql_is_running; then
                print_error "MySQL is not running"
                return 1
            fi
            print_info "Importing $file to $db..."
            docker exec -i "$MYSQL_CONTAINER_NAME" mysql -u root "$db" < "$file" || {
                print_error "Import failed"
                return 1
            }
            print_success "Imported $file to $db"
            ;;
        rm|remove)
            if mysql_is_running; then
                print_info "Stopping MySQL container..."
                docker stop "$MYSQL_CONTAINER_NAME" > /dev/null 2>&1
            fi
            if docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^${MYSQL_CONTAINER_NAME}$"; then
                print_info "Removing MySQL container..."
                docker rm "$MYSQL_CONTAINER_NAME" > /dev/null 2>&1
                print_success "MySQL container removed"
            else
                print_warning "MySQL container does not exist"
            fi
            ;;
        *)
            if ! mysql_is_running; then
                print_error "MySQL is not running"
                echo "  Start: pls start"
                return 1
            fi

            if [ $# -eq 0 ]; then
                docker exec -it "$MYSQL_CONTAINER_NAME" mysql -u root
            else
                docker exec -it "$MYSQL_CONTAINER_NAME" mysql -u root "$@"
            fi
            ;;
    esac
}

cmd_mail() {
    local subcmd="${1:-}"

    case "$subcmd" in
        start)
            mail_start ;;
        stop)
            mail_stop ;;
        restart)
            mail_stop; sleep 1; mail_start ;;
        status)
            if mail_is_running; then
                print_success "Mailpit is running"
                echo "  Container: $MAIL_CONTAINER_NAME"
                echo "  SMTP:      127.0.0.1:$MAIL_SMTP_PORT"
                echo "  Web UI:    https://mail.test"
                echo "  Image:     $(docker inspect --format '{{.Config.Image}}' "$MAIL_CONTAINER_NAME" 2>/dev/null)"
            else
                print_warning "Mailpit is not running"
            fi
            ;;
        open)
            print_info "Opening https://mail.test"
            open_url "https://mail.test"
            ;;
        rm|remove)
            if mail_is_running; then
                print_info "Stopping Mailpit container..."
                docker stop "$MAIL_CONTAINER_NAME" > /dev/null 2>&1
            fi
            if docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^${MAIL_CONTAINER_NAME}$"; then
                print_info "Removing Mailpit container..."
                docker rm "$MAIL_CONTAINER_NAME" > /dev/null 2>&1
                print_success "Mailpit container removed"
            else
                print_warning "Mailpit container does not exist"
            fi
            ;;
        *)
            echo ""
            print_header "Mailpit - Local Email Testing"
            echo ""
            if mail_is_running; then
                print_success "Status: running"
            else
                print_warning "Status: stopped"
            fi
            echo ""
            echo "  SMTP Host:     127.0.0.1"
            echo "  SMTP Port:     $MAIL_SMTP_PORT"
            echo "  Web UI:        https://mail.test"
            echo ""
            echo "  PHP config (php.ini):"
            echo "    sendmail_path = /usr/sbin/sendmail -S 127.0.0.1:$MAIL_SMTP_PORT"
            echo ""
            echo "  Laravel (.env):"
            echo "    MAIL_MAILER=smtp"
            echo "    MAIL_HOST=127.0.0.1"
            echo "    MAIL_PORT=$MAIL_SMTP_PORT"
            echo "    MAIL_ENCRYPTION=null"
            echo ""
            echo "  Symfony (.env):"
            echo "    MAILER_DSN=smtp://127.0.0.1:$MAIL_SMTP_PORT"
            echo ""
            echo "Commands:"
            echo "  pls mail start    Start Mailpit"
            echo "  pls mail stop     Stop Mailpit"
            echo "  pls mail restart  Restart Mailpit"
            echo "  pls mail status   Show status"
            echo "  pls mail open     Open Web UI in browser"
            echo "  pls mail rm       Remove container"
            echo ""
            ;;
    esac
}

cmd_logs() {
    local target="${1:-caddy}"

    case "$target" in
        caddy)
            journalctl --user -u pls-caddy.service -f
            ;;
        php)
            tail -f "$PHP_DIR"/logs/*.log 2>/dev/null || print_warning "No PHP logs"
            ;;
        mysql)
            if mysql_is_running; then
                docker logs -f "$MYSQL_CONTAINER_NAME"
            else
                print_warning "MySQL is not running"
            fi
            ;;
        mail|mailpit)
            if mail_is_running; then
                docker logs -f "$MAIL_CONTAINER_NAME"
            else
                print_warning "Mailpit is not running"
            fi
            ;;
        *)
            local logfile="$PLS_LOG_DIR/${target}.log"
            [ ! -f "$logfile" ] && logfile="$PLS_LOG_DIR/${target}.test.log"

            if [ -f "$logfile" ]; then
                tail -f "$logfile"
            else
                print_error "Log not found: $target"
            fi
            ;;
    esac
}

install_directories() {
    print_info "Creating directories..."
    mkdir -p "$PLS_CONFIG_DIR" "$PLS_SITES_DIR" "$PLS_CERTS_DIR" "$PLS_LOG_DIR"
    mkdir -p "$PHP_DIR" "$PHP_VERSIONS_DIR" "$PHP_RUN_DIR" "$PHP_DIR/logs"
    mkdir -p "$MYSQL_DIR" "$MYSQL_DATA_DIR"
    mkdir -p "$PROJECTS_DIR"
    mkdir -p "$HOME/.config/systemd/user"
    mkdir -p "$HOME/.local/bin"
    print_success "Directories created"
}

install_check_deps() {
    local missing=()

    command -v curl &> /dev/null || missing+=("curl")

    if [ ${#missing[@]} -gt 0 ]; then
        print_error "Missing dependencies: ${missing[*]}"
        echo "  Install: $(pkg_hint "${missing[@]}")"
        return 1
    fi
    return 0
}

install_caddy() {
    echo ""
    print_header "Installing Caddy"

    if [ -x "$CADDY_BIN" ]; then
        print_success "Caddy already installed: $("$CADDY_BIN" version 2>/dev/null | head -1)"
    else
        print_info "Installing Caddy..."
        if [ "$DISTRO_FAMILY" = "debian" ]; then
            sudo apt-get install -y debian-keyring debian-archive-keyring apt-transport-https curl 2>/dev/null
            curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | \
                sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg 2>/dev/null
            curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | \
                sudo tee /etc/apt/sources.list.d/caddy-stable.list >/dev/null
            sudo apt-get update >/dev/null
            sudo apt-get install -y caddy || {
                print_error "Failed to install Caddy"
                return 1
            }
        else
            pkg_install caddy || {
                print_error "Failed to install Caddy"
                return 1
            }
        fi
        CADDY_BIN="$(command -v caddy 2>/dev/null || echo /usr/sbin/caddy)"
    fi

    print_info "Setting port capability..."
    sudo setcap 'cap_net_bind_service=+ep' "$CADDY_BIN" 2>/dev/null || {
        print_warning "Failed to set capability (sudo required)"
    }

    print_info "Creating systemd service..."
    cat > "$HOME/.config/systemd/user/pls-caddy.service" << EOF
[Unit]
Description=Caddy Web Server (pls)
After=network.target

[Service]
Type=simple
ExecStart=$CADDY_BIN run --config %h/.config/pls/Caddyfile --adapter caddyfile
ExecReload=/usr/bin/curl -s http://localhost:2019/load -H "Content-Type: text/caddyfile" --data-binary @%h/.config/pls/Caddyfile
Restart=on-failure
RestartSec=5

[Install]
WantedBy=default.target
EOF

    systemctl --user daemon-reload
    systemctl --user enable pls-caddy.service 2>/dev/null || true
    init_caddyfile

    print_success "Caddy configured"
}

install_mkcert() {
    echo ""
    print_header "Installing mkcert (HTTPS)"

    local _nss_pkg="nss"
    [ "$DISTRO_FAMILY" = "debian" ] && _nss_pkg="libnss3-tools"

    if command -v mkcert &> /dev/null; then
        print_success "mkcert already installed"
    else
        print_info "Installing mkcert..."
        pkg_install mkcert "$_nss_pkg" || {
            print_error "Failed to install mkcert"
            [ "$DISTRO_FAMILY" = "debian" ] && echo "  On older Debian/Ubuntu: https://github.com/FiloSottile/mkcert/releases"
            return 1
        }
    fi

    if [ ! -d "$(mkcert -CAROOT 2>/dev/null)" ] || [ ! -f "$(mkcert -CAROOT)/rootCA.pem" ]; then
        print_info "Initializing local CA..."
        mkcert -install
    fi

    print_success "mkcert configured"
}

install_dnsmasq() {
    echo ""
    print_header "Installing dnsmasq (.test domain)"

    if command -v dnsmasq &> /dev/null; then
        print_success "dnsmasq already installed"
    else
        print_info "Installing dnsmasq..."
        pkg_install dnsmasq || {
            print_error "Failed to install dnsmasq"
            return 1
        }
    fi

    if grep -q "^#conf-dir=/etc/dnsmasq.d$" /etc/dnsmasq.conf 2>/dev/null; then
        print_info "Enabling dnsmasq conf-dir..."
        sudo sed -i 's/^#conf-dir=\/etc\/dnsmasq.d$/conf-dir=\/etc\/dnsmasq.d/' /etc/dnsmasq.conf
    fi

    # Detect upstream resolver
    local upstream_resolv="/etc/resolv.conf"
    if [ -f /run/NetworkManager/resolv.conf ]; then
        upstream_resolv="/run/NetworkManager/resolv.conf"
    elif [ -f /run/systemd/resolve/resolv.conf ]; then
        upstream_resolv="/run/systemd/resolve/resolv.conf"
    fi

    local dnsmasq_conf="/etc/dnsmasq.d/pls.conf"
    print_info "Configuring dnsmasq..."
    sudo mkdir -p /etc/dnsmasq.d
    cat << DNSCONF | sudo tee "$dnsmasq_conf" > /dev/null
# pls - PHP Local Server DNS config
# .test domain -> localhost
address=/test/127.0.0.1

# Use upstream DNS
resolv-file=$upstream_resolv

# Only bind to localhost
listen-address=127.0.0.1
bind-interfaces
DNSCONF

    sudo rm -f /etc/dnsmasq.d/test-tld.conf 2>/dev/null

    # Disable systemd-resolved stub listener (common on Debian/Ubuntu)
    if systemctl is-active --quiet systemd-resolved 2>/dev/null; then
        print_info "Disabling systemd-resolved stub listener..."
        sudo mkdir -p /etc/systemd/resolved.conf.d
        cat << 'RESCONF' | sudo tee /etc/systemd/resolved.conf.d/pls-no-stub.conf > /dev/null
[Resolve]
DNSStubListener=no
RESCONF
        sudo systemctl restart systemd-resolved
    fi

    if [ -d "/etc/NetworkManager" ]; then
        local nm_conf="/etc/NetworkManager/conf.d/dns.conf"
        print_info "Configuring NetworkManager..."
        sudo rm -f /etc/NetworkManager/conf.d/dnsmasq.conf 2>/dev/null
        cat << 'NMCONF' | sudo tee "$nm_conf" > /dev/null
[main]
dns=none
NMCONF
    fi

    print_info "Configuring /etc/resolv.conf..."
    sudo chattr -i /etc/resolv.conf 2>/dev/null || true
    echo "nameserver 127.0.0.1" | sudo tee /etc/resolv.conf > /dev/null
    sudo chattr +i /etc/resolv.conf

    print_info "Restarting services..."
    sudo systemctl enable dnsmasq
    sudo systemctl restart dnsmasq
    sudo systemctl restart NetworkManager 2>/dev/null || true

    sleep 1

    print_info "Verifying DNS..."
    if dig +short google.com @127.0.0.1 2>/dev/null | grep -qE '^[0-9]+\.'; then
        print_success "Internet DNS working"
    else
        print_warning "Internet DNS may not be working"
    fi

    if dig +short anything.test @127.0.0.1 2>/dev/null | grep -q "127.0.0.1"; then
        print_success ".test domain working"
    else
        print_warning ".test domain resolution failed"
    fi

    print_success "dnsmasq configured"
}

install_mysql() {
    echo ""
    print_header "Installing MySQL (Docker)"

    require_docker || return 1

    print_info "Pulling MySQL image: $MYSQL_IMAGE"
    docker pull "$MYSQL_IMAGE" || {
        print_error "Failed to pull MySQL image"
        return 1
    }

    mkdir -p "$MYSQL_DATA_DIR"

    print_success "MySQL Docker configured"
    echo ""
    echo "  Image:     $MYSQL_IMAGE"
    echo "  Container: $MYSQL_CONTAINER_NAME"
    echo "  Port:      127.0.0.1:$MYSQL_PORT"
    echo "  Data:      $MYSQL_DATA_DIR"
    echo "  User:      root (no password)"
    echo ""
    echo "  Start:   pls mysql start"
    echo "  Connect: pls mysql"
    echo "           mysql -h 127.0.0.1 -P $MYSQL_PORT -u root"
}

install_mail() {
    echo ""
    print_header "Installing Mailpit (Local Email Testing)"

    require_docker || return 1

    print_info "Pulling Mailpit image: $MAIL_IMAGE"
    docker pull "$MAIL_IMAGE" || {
        print_error "Failed to pull Mailpit image"
        return 1
    }

    print_info "Creating mail.test site configuration..."
    generate_cert "mail.test" || return 1

    local mail_site_file="$PLS_SITES_DIR/mail.test.conf"
    cat > "$mail_site_file" << EOF
# Mailpit - Local Email Testing
http://mail.test {
    redir https://{host}{uri} permanent
}

https://mail.test {
    tls $PLS_CERTS_DIR/mail.test.pem $PLS_CERTS_DIR/mail.test-key.pem
    reverse_proxy 127.0.0.1:$MAIL_UI_PORT
    log {
        output file $PLS_LOG_DIR/mail.test.log
    }
}
EOF

    print_success "Mailpit configured"
    echo ""
    echo "  Image:      $MAIL_IMAGE"
    echo "  Container:  $MAIL_CONTAINER_NAME"
    echo "  SMTP:       127.0.0.1:$MAIL_SMTP_PORT"
    echo "  Web UI:     https://mail.test"
    echo ""
    echo "  Start:   pls mail start"
    echo "  Open:    pls mail open"
    echo "  Config:  pls mail"

    caddy_is_running && caddy_reload
}

ensure_spc_image() {
    if docker image inspect "$SPC_DOCKER_IMAGE" &>/dev/null; then
        return 0
    fi

    require_docker || return 1

    print_info "Building spc Docker image (one-time setup)..."
    docker build -t "$SPC_DOCKER_IMAGE" - <<'DOCKERFILE'
FROM alpine:latest
RUN apk add --no-cache \
    bash curl gcc g++ git make autoconf automake bison re2c cmake libtool \
    linux-headers pkgconf perl patch file binutils flex tar xz bzip2 zip \
    libarchive-tools rsync texinfo gettext-dev icu-dev zlib-dev ccache
RUN curl -fsSL https://dl.static-php.dev/static-php-cli/spc-bin/nightly/spc-linux-x86_64 \
    -o /usr/local/bin/spc && chmod +x /usr/local/bin/spc
WORKDIR /build
RUN spc doctor --auto-fix
DOCKERFILE

    if [ $? -eq 0 ]; then
        print_success "spc Docker image built"
    else
        print_error "Failed to build spc Docker image"
        return 1
    fi
}

install_php_version() {
    local version="$1"
    local version_dir="$PHP_VERSIONS_DIR/php-${version}"

    if [ -d "$version_dir" ] && [ -x "$version_dir/php" ] && [ -x "$version_dir/php-fpm" ]; then
        print_warning "PHP $version already installed"
        return 0
    fi

    ensure_spc_image || return 1

    mkdir -p "$SPC_CACHE_DIR" "$version_dir"

    print_info "Building PHP $version with static-php-cli..."
    print_info "Extensions: $SPC_EXTENSIONS"
    print_warning "First build may take several minutes"

    local gh_token="${GITHUB_TOKEN:-$(gh auth token 2>/dev/null)}"
    local -a docker_env=()
    [ -n "$gh_token" ] && docker_env+=(-e "GITHUB_TOKEN=$gh_token")

    docker run --rm \
        "${docker_env[@]}" \
        -e "HOST_UID=$(id -u)" -e "HOST_GID=$(id -g)" \
        -v "$SPC_CACHE_DIR:/build/downloads" \
        -v "$version_dir:/dist" \
        "$SPC_DOCKER_IMAGE" \
        bash -c "
            spc download --with-php=$version --for-extensions=\"$SPC_EXTENSIONS\" --prefer-pre-built && \
            spc build \"$SPC_EXTENSIONS\" --build-cli --build-fpm; \
            cp buildroot/bin/php buildroot/bin/php-fpm /dist/ 2>/dev/null && \
            chown \$HOST_UID:\$HOST_GID /dist/php /dist/php-fpm 2>/dev/null
        "

    if [ -f "$version_dir/php" ] && [ -f "$version_dir/php-fpm" ]; then
        chmod +x "$version_dir/php" "$version_dir/php-fpm"
    else
        print_error "Build produced no binaries"
        return 1
    fi

    install_php_fpm_config "$version"

    local php_full=$("$version_dir/php" -v 2>/dev/null | head -1 | cut -d' ' -f2 || echo "$version")
    print_success "PHP $php_full built and installed"
}

install_php_fpm_config() {
    local version="$1"
    local version_dir="$PHP_VERSIONS_DIR/php-${version}"
    local fpm_conf="$version_dir/php-fpm.conf"
    local pool_conf="$version_dir/php-fpm.d/www.conf"

    mkdir -p "$version_dir/php-fpm.d"

    cat > "$fpm_conf" << EOF
[global]
pid = $PHP_RUN_DIR/php${version}-fpm.pid
error_log = $PHP_DIR/logs/php${version}-fpm.log
daemonize = yes

include = $version_dir/php-fpm.d/*.conf
EOF

    cat > "$pool_conf" << EOF
[www]
user = $USER
group = $USER

listen = $PHP_RUN_DIR/php${version}-fpm.sock
listen.owner = $USER
listen.group = $USER
listen.mode = 0660

pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3

catch_workers_output = yes
EOF
}

install_php_all() {
    echo ""
    print_header "Installing PHP versions"

    local versions=("8.2" "8.3" "8.4" "8.5")

    for version in "${versions[@]}"; do
        install_php_version "$version" || true
    done

    print_info "Creating PHP-FPM systemd service..."
    cat > "$HOME/.config/systemd/user/pls-php.service" << 'EOF'
[Unit]
Description=PHP-FPM (pls)
After=network.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=%h/.local/bin/pls php start
ExecStop=%h/.local/bin/pls php stop

[Install]
WantedBy=default.target
EOF

    systemctl --user daemon-reload
    systemctl --user enable pls-php.service 2>/dev/null || true

    print_success "PHP-FPM configured"
}

install_composer() {
    echo ""
    print_header "Installing Composer"

    local composer_bin="$PLS_DIR/composer"

    if [ -x "$composer_bin" ]; then
        local php_bin=$(php_get_bin "$DEFAULT_PHP_VERSION")
        [ -z "$php_bin" ] && php_bin="php"
        print_success "Composer already installed: $("$php_bin" "$composer_bin" --version 2>/dev/null | head -1)"
        return 0
    fi

    print_info "Downloading Composer..."

    local php_bin=$(php_get_bin "$DEFAULT_PHP_VERSION")
    [ -z "$php_bin" ] && php_bin="php"

    curl -sS https://getcomposer.org/installer | "$php_bin" -- --install-dir="$PLS_DIR" --filename=composer || {
        print_error "Failed to install Composer"
        return 1
    }

    chmod +x "$composer_bin"
    print_success "Composer installed: $PLS_DIR/composer"
}

install_linger() {
    echo ""
    print_header "Enabling systemd linger (boot autostart)"

    if loginctl show-user "$USER" 2>/dev/null | grep -q "Linger=yes"; then
        print_success "Linger already enabled"
    else
        print_info "Enabling linger..."
        loginctl enable-linger "$USER" || sudo loginctl enable-linger "$USER" || {
            print_warning "Failed to enable linger"
            return 1
        }
        print_success "Linger enabled"
    fi
}

install_shell_aliases() {
    echo ""
    print_header "Shell aliases"

    echo ""
    echo "Add to your shell configuration (~/.bashrc or ~/.zshrc):"
    echo ""
    echo -e "  ${CYAN}# pls - PHP Local Server${NC}"
    echo -e "  ${CYAN}alias php=\"pls php\"${NC}"
    echo -e "  ${CYAN}alias composer=\"pls composer\"${NC}"
    echo -e "  ${CYAN}alias mysql=\"pls mysql\"${NC}"
    echo ""
}

cmd_install() {
    local component="${1:-all}"

    echo ""
    print_header "pls - PHP Local Server Installer"
    echo ""

    case "$component" in
        all)
            install_check_deps || return 1
            install_directories
            install_caddy
            install_mkcert
            install_dnsmasq
            install_mysql
            install_mail
            install_php_all
            install_composer
            install_linger

            echo ""
            print_header "Installation complete!"
            echo ""
            echo "  Start:   pls start"
            echo "  Status:  pls status"
            echo "  Project: cd ~/Codes/myapp && pls serve"
            echo "  Mail:    https://mail.test"
            echo ""

            install_shell_aliases
            ;;
        php)
            shift 2>/dev/null || true
            if [ -n "$1" ]; then
                install_php_version "$1"
            else
                install_php_all
            fi
            ;;
        caddy)
            install_caddy
            ;;
        mkcert)
            install_mkcert
            ;;
        dnsmasq|dns)
            install_dnsmasq
            ;;
        mysql|mariadb)
            install_mysql
            ;;
        mail|mailpit)
            install_mail
            ;;
        composer)
            install_composer
            ;;
        *)
            echo "Usage: pls install [component]"
            echo ""
            echo "Components:"
            echo "  all       Full installation (default)"
            echo "  php [ver] PHP versions (or a specific one)"
            echo "  caddy     Caddy webserver"
            echo "  mkcert    mkcert (HTTPS)"
            echo "  dnsmasq   dnsmasq (.test domain)"
            echo "  mysql     MySQL/MariaDB"
            echo "  mail      Mailpit (local email testing)"
            echo "  composer  Composer"
            ;;
    esac
}

cmd_help() {
    cat <<EOF
${BOLD}${CYAN}pls${NC} - PHP Local Server v${VERSION}

${BOLD}USAGE${NC}
  pls <command> [options]

${BOLD}ENVIRONMENT MANAGEMENT${NC}
  ${BLUE}start${NC}              Start all services (Caddy + PHP-FPM + MySQL)
  ${BLUE}stop${NC}               Stop all services
  ${BLUE}restart${NC}            Restart
  ${BLUE}status${NC}             Show status

${BOLD}SITE MANAGEMENT${NC}
  ${BLUE}serve${NC} [project]    Serve project (or current folder)
  ${BLUE}alias${NC} <site> <new> Add alias domain to existing site
  ${BLUE}remove${NC} <host>      Remove site or alias
  ${BLUE}list${NC}               List active sites
  ${BLUE}info${NC} <host>        Show detailed site information
  ${BLUE}open${NC} <host>        Open site in browser
  ${BLUE}edit${NC} <host>        Edit site config in \$EDITOR
  ${BLUE}projects${NC}           List available projects

${BOLD}PHP & COMPOSER (alias php="pls php" composer="pls composer")${NC}
  ${BLUE}php${NC}                Show PHP version (based on project)
  ${BLUE}php${NC} <args>         Run PHP with appropriate version
  ${BLUE}php artisan${NC} ...    Laravel Artisan
  ${BLUE}composer${NC}           Composer version (with project PHP)
  ${BLUE}composer${NC} <args>    Run Composer (install, update, etc.)

${BOLD}PHP-FPM MANAGEMENT${NC}
  ${BLUE}php list${NC}           List installed PHP versions
  ${BLUE}php start${NC} [ver]    Start PHP-FPM
  ${BLUE}php stop${NC} [ver]     Stop PHP-FPM
  ${BLUE}php restart${NC} [ver]  Restart PHP-FPM

${BOLD}MYSQL (Docker, alias mysql="pls mysql")${NC}
  ${BLUE}mysql${NC}              Open MySQL CLI (root, no password)
  ${BLUE}mysql${NC} <args>       Run MySQL client with arguments
  ${BLUE}mysql start${NC}        Start MySQL container
  ${BLUE}mysql stop${NC}         Stop MySQL container
  ${BLUE}mysql restart${NC}      Restart MySQL container
  ${BLUE}mysql status${NC}       Show MySQL status
  ${BLUE}mysql rm${NC}           Remove MySQL container
  ${BLUE}mysql export${NC} <db> <file>  Export database to SQL file
  ${BLUE}mysql import${NC} <db> <file>  Import SQL file to database

${BOLD}MAILPIT (Local Email Testing)${NC}
  ${BLUE}mail${NC}               Show Mailpit info & config examples
  ${BLUE}mail start${NC}         Start Mailpit container
  ${BLUE}mail stop${NC}          Stop Mailpit container
  ${BLUE}mail restart${NC}       Restart Mailpit container
  ${BLUE}mail status${NC}        Show Mailpit status
  ${BLUE}mail open${NC}          Open Web UI in browser (https://mail.test)
  ${BLUE}mail rm${NC}            Remove Mailpit container

${BOLD}INSTALLATION${NC}
  ${BLUE}install${NC}            Full environment installation
  ${BLUE}install php${NC} [ver]  Install PHP versions
  ${BLUE}install mysql${NC}      Pull MySQL Docker image
  ${BLUE}install mail${NC}       Install Mailpit (local email)
  ${BLUE}install composer${NC}   Install Composer

${BOLD}OTHER${NC}
  ${BLUE}logs${NC} [target]      Show logs (caddy/php/mysql/site)
  ${BLUE}trust${NC}              Check/fix mkcert CA trust status
  ${BLUE}help${NC}               Show help
  ${BLUE}version${NC}            Show version

${BOLD}EXAMPLES${NC}
  pls start                      # Start environment
  cd ~/Codes/myapp && pls serve  # Serve project
  pls serve myapp                # Serve project by name
  pls alias myapp api.myapp      # Add api.myapp.test alias
  pls open myapp                 # Open in browser
  pls info myapp                 # Show site details
  pls edit myapp                 # Edit Caddy config

  cd ~/Codes/myapp && pls php    # PHP version (8.4 if in composer.json)
  pls php artisan migrate        # Laravel migration with correct PHP
  pls composer install           # Composer with correct PHP

  pls php list                   # PHP-FPM versions
  pls mysql                      # Open MySQL CLI
  pls mysql -e "SHOW DATABASES"  # Run MySQL query
  pls mysql export mydb backup.sql  # Export database
  pls mysql import mydb backup.sql  # Import database

  pls mail                       # Show mail config examples
  pls mail open                  # Open Mailpit UI

  pls logs mysql                 # MySQL error log
  pls logs mail                  # Mailpit logs
  pls logs myapp.test            # Site log
  pls trust                      # Check CA trust status

${BOLD}PHP VERSION DETECTION${NC}
  1. composer.json require.php
  2. .php-version file
  3. .phpversion file
  4. Default: $DEFAULT_PHP_VERSION

${BOLD}FILES${NC}
  Config:   $PLS_CONFIG_DIR
  Sites:    $PLS_SITES_DIR
  Certs:    $PLS_CERTS_DIR
  Logs:     $PLS_LOG_DIR
  PHP:      $PHP_DIR
  MySQL:    $MYSQL_DIR
  Projects: $PROJECTS_DIR
EOF
}

main() {
    local cmd="${1:-help}"
    shift 2>/dev/null || true

    case "$cmd" in
        start)          cmd_start ;;
        stop)           cmd_stop ;;
        restart)        cmd_restart ;;
        status|st)      cmd_status ;;
        serve)          serve_project "$@" ;;
        alias)          alias_site "$@" ;;
        remove|rm)      remove_site "$@" ;;
        list|ls|sites)  list_sites ;;
        open)           open_site "$@" ;;
        edit)           edit_site "$@" ;;
        info)           info_site "$@" ;;
        projects|proj)  cmd_projects ;;
        php)            cmd_php "$@" ;;
        composer)       cmd_composer "$@" ;;
        mysql)          cmd_mysql "$@" ;;
        mail|mailpit)   cmd_mail "$@" ;;
        install)        cmd_install "$@" ;;
        logs|log)       cmd_logs "$@" ;;
        trust)          cmd_trust ;;
        reload)         caddy_reload ;;
        help|--help|-h) cmd_help ;;
        version|-v|--version) echo "pls version $VERSION" ;;
        *)
            print_error "Unknown command: $cmd"
            echo "  Usage: pls help"
            exit 1
            ;;
    esac
}

main "$@"
